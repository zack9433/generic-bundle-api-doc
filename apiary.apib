FORMAT: 1A
HOST: http://www.google.com

# MXcloud Generic
Notes API is a *short texts saving* service similar to its physical paper presence on your table.

# Group Cellular
Notes related resources of the **Cellular API**

## Cellular Collection [/network/cellulars]
### List all Cellular Configurations [GET]

The Collection response has following attributes:

+ Response 200 (application/json)

        [
          {
            "id": 1,
            "name": "wwan1",
            "mode": "umts",
            "signal": -96,
            "operatorName": "Chunghwa Telecom",
            "lac": "0xF339",
            "cellId": "0x3194",
            "iccId": "",
            "imei": "356853050370859",
            "pinRetryRemain": 3,

            "status": "connected",
            "ip": "111.70.146.125",
            "netmask": "255.255.255.252",
            "gateway": "111.70.146.126",
            "dns": ["168.95.1.1" , "168.95.192.1"],
            "usage": {
                "txkbyte": 40023,
                "rxkbyte": 3493
            },

            "enable": true,
            "apn": "internet",
            "pinCode": "0000",

            "keepalive":
            {
              "enable": true,
              "targetHost": "8.8.8.8",
              "intervalSec": 60
            }
          }
        ]


## Cellular [/network/cellulars/{id}]
A single Cellular object with all its details

+ Parameters
    + id (required, number, `1`) ... Numeric `id` of the Cellular to perform action with. Has example value.

### Retrieve an Cellular [GET]

The response for GET has following attributes:

- **id** (number, `1`): Identifier for an Cellular interface.
- **name** (string, `wwan0`): Interface name.
- **mode** (string, `umts`): Given cellular connection mode. Could be one of `"umts"`, `"lte"`.
- **signal** (number, `-99`): Cellular RF signal strength, in `dbm`. Value `0` indicates no SIM card found.
- **operatorName** (string, ``): Indicate current operator name if exist.
- **lac** (string, `0xF339`): Location area code.
- **cellId** (string, `0x3194`): Cell ID.
- **iccId** (string, `""`): ICC ID of SIM card.
- **imei** (string, `"356853050370859"`): IMEI of cellular module.
- **pinRetryRemain** (number, `3`): PIN Retry remaining.

- **status** (string, `connected`): Indicate current status of cellular connection. Could be one of "nosim", "pin", "noservice", "ready", "connected", "connecting", "connect-failed".
- **ip** (IP address, `111.70.146.125`): IP address. `""` when not connected.
- **netmask** (IP address, `255.255.255.252`): Subnet mask. `""` when not connected.
- **gateway** (IP address, `192.168.3.254`): Gateway IP address. `""` when not connected.
- **dns** (IP address array): A list of DNS IP addresses. `[]` when not connected.
- **usage** (object): Data usage.
    - **txkbyte**(number, `40023`): Amount of data transmitted, in Kbytes.
    - **rxkbyte**(number, `3493`): Amount of data received, in Kbytes.

- **enable** (boolean, `true`): Enable Cellular Networking.
- **apn** (string, `internet`): APN used when dialing up to Cellular Network.
- **pinCode** (string, `0000`): PIN code of SIM card. Takes no effect when SIM card PIN weren't not set.
- **keepalive** (object): Keep-alive configuration.
    - **enable** (boolean, `true`): Enable/disable Cellular connection keep-alive by ping.
    - **targetHost** (string, `8.8.8.8`): IP address to ping.
    - **intervalSec** (number, `60`): Check alive interval.

+ Response 200 (application/json; charset=utf-8)

        {
            "id": 1,
            "name": "wwan1",
            "mode": "umts",
            "signal": -96,
            "operatorName": "Chunghwa Telecom",
            "lac": "0xF339",
            "cellId": "0x3194",
            "iccId": "",
            "imei": "356853050370859",
            "pinRetryRemain": 3,

            "status": "connected",
            "ip": "111.70.146.125",
            "netmask": "255.255.255.252",
            "gateway": "111.70.146.126",
            "dns": ["168.95.1.1" , "168.95.192.1"],
            "usage": {
                "txkbyte": 40023,
                "rxkbyte": 3493
            },

            "enable": true,
            "apn": "internet",
            "pinCode": "0000",

            "keepalive":
            {
              "enable": true,
              "targetHost": "8.8.8.8",
              "intervalSec": 60
            }
        }


### Update Cellular Configuration [PUT]

The request for PUT has following attributes:

- **id** (required, number, `1`): Identifier for an Cellular interface. Should match `id` in URL.
- **enable** (required, boolean, `true`): Enable/disable Cellular connection.
- **pinCode** (required, string, `0000`): Use this code to auth when exits.
- **apn** (required, string, ``): Indicate apn of SIM card.
- **keepalive** (required, object): Keep-alive configuration.
    - **enable** (required, boolean, `true`): Enable/disable Cellular connection keep-alive by ping.
    - **targetHost** (required, string, `8.8.8.8`): IP address to ping.
    - **intervalSec** (required, number, `60`): Check alive interval. Criteria `60 <= v < 86400`.

The response for PUT is same as that for GET but:

- **restart** (optional, number, `0`): `1` means that view must be restarted after receiving the response.

The error response has following attributes:

- **message** (required, string): Error message in English.

+ Request (application/json)

        {
            "id": 1,
            "enable": true,
            "apn": "internet",
            "pinCode": "0000",

            "keepalive":
            {
              "enable": true,
              "targetHost": "8.8.8.8",
              "intervalSec": 60
            }
        }

+ Response 200 (application/json)

        {
            "id": 1,
            "name": "wwan1",
            "mode": "umts",
            "signal": -96,
            "operatorName": "Chunghwa Telecom",
            "lac": "0xF339",
            "cellId": "0x3194",
            "iccId": "",
            "imei": "356853050370859",
            "pinRetryRemain": 3,

            "status": "connected",
            "ip": "111.70.146.125",
            "netmask": "255.255.255.252",
            "gateway": "111.70.146.126",
            "dns": ["168.95.1.1" , "168.95.192.1"],
            "usage": {
                "txkbyte": 40023,
                "rxkbyte": 3493
            },

            "enable": true,
            "apn": "internet",
            "pinCode": "0000",

            "keepalive":
            {
              "enable": true,
              "targetHost": "8.8.8.8",
              "intervalSec": 60
            }

        }

+ Response 400 (application/json)

        {
            "message": "Unable to apply!"
        }

# Group Ethernet
Notes related resources of the **Ethernet API**

## Ethernet Collection [/network/ethernets]
### List all Ethernets [GET]

The Collection response has following attributes:

+ Response 200 (application/json; charset=utf-8)

        [
            {
                "id":1,
                "wan":1,
                "name": "eth0",
                "ip": "192.168.3.127",
                "mac": "FF:FF:FF:FF:FF:FF",
                "netmask": "255.255.255.0",
                "subnet": "192.168.3.0",
                "gateway": "192.168.3.254",
                "dns":["8.8.8.8", "8.8.4.4"],
                "currentStatus":1,
                "enable":1,
                "enableDhcp":0
            },
            {
                "id":2,
                "wan":0,
                "name": "eth1",
                "ip": "192.168.3.127",
                "mac": "FF:FF:FF:FF:FF:FF",
                "netmask": "255.255.255.0",
                "subnet": "192.168.3.0",
                "gateway": "192.168.3.254",
                "dns":["8.8.8.8", "8.8.4.4"],
                "currentStatus":1,
                "enable":1,
                "enableDhcp":0
            }
        ]

### Update some Ethernets [PUT]

The collection request/response for update has following attributes:

+ Request (application/json; charset=utf-8)

        [
            {
                "id":2,
                "wan":0,
                "ip": "192.168.100.127",
                "netmask": "255.255.255.0",
                "subnet": "192.168.100.0",
                "gateway": "192.168.100.254",
                "dns":["8.8.8.8", "8.8.4.4"],
                "enable":1,
                "enableDhcp":0
            }
        ]

+ Response 200 (application/json; charset=utf-8)

        [
            {
                "id":1,
                "wan":1,
                "name": "eth0",
                "ip": "192.168.3.127",
                "mac": "FF:FF:FF:FF:FF:FF",
                "netmask": "255.255.255.0",
                "subnet": "192.168.3.0",
                "gateway": "192.168.3.254",
                "dns":["8.8.8.8", "8.8.4.4"],
                "currentStatus":1,
                "enable":1,
                "enableDhcp":0
            },
            {
                "id":2,
                "wan":0,
                "name": "eth1",
                "ip": "192.168.100.127",
                "mac": "FF:FF:FF:FF:FF:FF",
                "netmask": "255.255.255.0",
                "subnet": "192.168.100.0",
                "gateway": "192.168.100.254",
                "dns":["8.8.8.8", "8.8.4.4"],
                "currentStatus":1,
                "enable":1,
                "enableDhcp":0,
                "restart":1
            }
        ]

## Ethernet [/network/ethernets/{id}]
A single Ethernet object with all its details

+ Parameters
    + id (required, number, `1`) ... Numeric `id` of the Ethernet to perform action with. Has example value.

### Retrieve an Ethernet [GET]

The response for GET has following attributes:

- **id** (required, number, `1`): Identifier for an Ethernet interface.
- **wan** (required, number, `1`, default `0`): Define the interface type is WAN (`1`) or LAN (`0`)
- **name** (required, string, `eth0`): Indicate the interface name.
- **ip** (required, IP address, `192.168.3.127`): IP address for the Ethernet interface.
- **mac** (required, MAC, `FF:FF:FF:FF:FF:FF`): The identical MAC address.
- **netmask** (required, IP address, `255.255.255.0`): Subnet mask for the Ethernet interface.
- **subnet** (required, IP address, `192.168.3.0`): A subnet (short for "subnetwork") is an identifiably separate part of an organization's network.
- **gateway** (required, IP address, `192.168.3.254`): Gateway is a router or a proxy server that routes between networks.
- **dns** (required, IP address array): The Domain Name System (DNS) is a hierarchical distributed naming system for computers, services, or any resource connected to the Internet or a private network.
- **currentStatus** (required, number `1`): Current status for the Ethernet interface, 0 for down and 1 for up.
- **enable** (required, number, `1`): Indicate the link status of Ethernet interface should be set to up (`1`) or down (`0`).
- **enableDhcp** (required, number, `0`): Enable (`1`) the dhcp client or using the static IP (`0`).

+ Response 200 (application/json; charset=utf-8)

    + Body

            {
                "id":1,
                "wan":1,
                "name": "eth0",
                "ip": "192.168.3.127",
                "mac": "FF:FF:FF:FF:FF:FF",
                "netmask": "255.255.255.0",
                "subnet": "192.168.3.0",
                "gateway": "192.168.3.254",
                "dns":["8.8.8.8", "8.8.4.4"],
                "currentStatus":1,
                "enable":1,
                "enableDhcp":0
            }

### Update an Ethernet [PUT]

The request for PUT has following attributes:

- **wan** (optional, number, `1`, default `0`): Define the interface type is WAN (`1`) or LAN (`0`)
- **ip** (required, IP address, `192.168.3.127`): IP address for the Ethernet interface.
- **netmask** (required, IP address, `255.255.255.0`): Subnet mask for the Ethernet interface.
- **subnet** (required, IP address, `192.168.3.0`): A subnet (short for "subnetwork") is an identifiably separate part of an organization's network.
- **gateway** (optional, IP address, `192.168.3.254`): Gateway is a router or a proxy server that routes between networks.
- **dns** (optional, IP address array): The Domain Name System (DNS) is a hierarchical distributed naming system for computers, services, or any resource connected to the Internet or a private network.
- **enable** (required, number, `1`): Indicate the link status of Ethernet interface should be set to up (`1`) or down (`0`).
- **enableDhcp** (required, number, `0`): Enable (`1`) the dhcp client or using the static IP (`0`).

The response for PUT is same as that for GET.

The error response has following attributes:

- **status** (required, number, `1100`): Status code for error message.
- **message** (required, string): Error message in English.

+ Request (application/json; charset=utf-8)

        {
            "id": 2,
            "wan":0,
            "ip": "192.168.3.127",
            "netmask": "255.255.255.0",
            "subnet": "192.168.3.0",
            "gateway": "192.168.3.254",
            "dns":["8.8.8.8", "8.8.4.4"],
            "enable":1,
            "enableDhcp":0
        }

+ Response 200 (application/json; charset=utf-8)

        {
            "id":2,
            "wan":0,
            "name": "eth1",
            "ip": "192.168.100.127",
            "mac": "FF:FF:FF:FF:FF:FF",
            "netmask": "255.255.255.0",
            "subnet": "192.168.100.0",
            "gateway": "192.168.100.254",
            "dns":["8.8.8.8", "8.8.4.4"],
            "currentStatus":1,
            "enable":1,
            "enableDhcp":0
        }

+ Response 404 (application/json; charset=utf-8)

        {
            "status": 2101,
            "message": "Interface not found!"
        }


# Group DHCP Server
Notes related resources of the **DHCP Server API**

## DHCP server Collection [/network/dhcpd]
### List all DHCP Interfaces [GET]

The Collection response has following attributes:

- **currentStatus** (required, integer, 1): DHCP server status, 1: server is on, 0: server is off.
- **collection** (required, object array): An object array to perform all queried entries.

+ Response 200 (application/json; charset=utf-8)

        {
            "currentStatus": 1,
            "collection": [
                {
                    "id": 1,
                    "name": "eth0",
                    "enable": 0,
                    "subnet": "192.168.3.0",
                    "netmask": "255.255.255.0",
                    "startIP": "192.168.3.100",
                    "endIP": "192.168.3.150",
                    "domainNameServers": ["8.8.8.8", "1.1.1.1", "2.2.2.2"],
                    "domainName": "cloud 5566",
                    "leaseTime": "3600"
                }
            ]
        }


## DHCP server [/network/dhcpd/{id}]

+ Parameters
    + id (required, number, `1`) ... ID of the request in the form of a integer

### List request DHCP Interfaces [GET]

The response has following attributes:

- **currentStatus** (required, integer, 1):  1: server is on, 0: server is off.
- **collection** (required, object array): An object array to perform all queried entries.

+ Response 200 (application/json; charset=utf-8)

        {
            "id": 1,
            "name": "eth0",
            "enable": 1,
            "subnet": "192.168.3.0",
            "netmask": "255.255.255.0",
            "startIP": "192.168.3.100",
            "endIP": "192.168.3.150",
            "domainNameServers": ["8.8.8.8", "1.1.1.1", "2.2.2.2"],
            "domainName": "cloud 5566",
            "leaseTime": "3600"
        }

### Update some DHCP Interfaces [PUT]

The collection request/response for update has following attributes:

- **currentStatus** (required, integer, 1): server status, 1: server is on, 0: server is off.
- **collection** (required, object array): An object array to perform all queried entries.
- **collection[]id** (required, integer): index
- **collection[]name** (required, string): interfece of DHCP server, user can select eth0 or eth1
- **collection[]enable** (required, integer): interfece DHCP server enable bit
- **collection[]subnet** (required, string): subnet
- **collection[]netmask** (required, string): netmask
- **collection[]startIP** (required, string): start IP of DHCP server
- **collection[]endIP** (required, string): end IP of DHCP server
- **collection[]domainNameServers** (optional, object array): an object array to save dns list
- **collection[]domainName** (optional, string): DHCP server domain name
- **collection[]leaseTime** (required, string): leasetime of DHCP server

Suppose user want to update DHCP server of eth0 interface

+ Request  (application/json; charset=utf-8)

        {
            "id": 1,
            "name": "eth0",
            "enable": 1,
            "subnet": "192.168.3.0",
            "netmask": "255.255.255.0",
            "startIP": "192.168.3.100",
            "endIP": "192.168.3.150",
            "domainNameServers": ["8.8.8.8", "1.1.1.1", "2.2.2.2"],
            "domainName": "cloud 7788",
            "leaseTime": "3600"
        }


+ Response 200 (application/json; charset=utf-8)

        {
            "id": 1,
            "name": "eth0",
            "enable": 1,
            "subnet": "192.168.3.0",
            "netmask": "255.255.255.0",
            "startIP": "192.168.3.100",
            "endIP": "192.168.3.150",
            "domainNameServers": ["8.8.8.8", "1.1.1.1", "2.2.2.2"],
            "domainName": "cloud 5566",
            "leaseTime": "3600"
        }


# Group Firmware
Notes related resources of the **Firmware API**

## Firmware Upgrade [/system/firmware]
The firmware information with all its details

### Firmware Upgrade [POST]
The request for PUT has following attributes:

- **delay** (optional, number, `3`): Delay time in seconds before execute the upgrading process.
- **file.url** (required, string, `3`): Reboot delay time in seconds.
- **file.headers** (optional, object): Headers for fetch the file if necessary.

+ Request  (application/json)

        {
          "id": 3,
          "resource": "/system/firmware",
          "method": "post",
          "data": {
            "delay": 3,
            "file": {
              "url": "http://192.168.31.81:5000/api/v1/download/1234",
              "headers": {
                "accessToken": "MOXAMOXA-TEST-SYSTEM"
              }
            }
          }
        }

+ Response 200 (application/json)

        {}


# Group ImportExport
Notes related resources of the **ImportExport API**

## Import [/system/import]
The importexport object allows user to import/export configuration files to/from the system.

### Import the system [PUT]
The request for PUT has following attributes:

- **file.url** (required, string, `3`): File http url.
- **file.headers** (optional, object): Headers for fetch the file if necessary.
- **scopes** (required, array): List of import scopes. Now avaliable scopes: modbus, relay, time, dns, ethernet, cellular, dhcpd, serial, portforwarding

+ Request  (application/json)

        {
          "id": 3,
          "resource": "/system/import",
          "method": "put",
          "data": {
            "scopes": ["modbus", "cellular", "time"],
            "file": {
              "url": "http://192.168.31.81:5000/api/v1/download/1234",
              "headers": {
                "accessToken": "MOXAMOXA-TEST-SYSTEM"
              }
            }
          }
        }

+ Response 200 (application/json)

        {}

## Export [/system/export]

### Export the system [GET]

The response for GET would be a file.
(From web to backend)

+ Request  (application/json)


+ Response 200 (application/octet-stream)

        ```binary data goes here```

### Export the system [POST]
(From backend to bundle)
The response for GET has following attributes:

+ Request  (application/json)

        {
          "url": "https://server/upload",
          "headers": {
            "accessToken": "MOXAMOXA-TEST-SYSTEM"
          }
        }

+ Response 200 (application/json)

        {
          "url": "https://server/upload/xxxxxxx"
        }


# Group Reboot
Notes related resources of the **Reboot API**

## Reboot [/system/reboot]
The reboot object allows user to reboot the system

### Reboot the system [PUT]

The response for PUT has following attributes:

- **enable** (required, number, `1`): Indicate the system will be reboot soon.

+ Request  (application/json)

        {
            "enable": 1
        }

+ Response 200 (application/json)

        {
            "enable": 1
        }

+ Response 404 (application/json)

        {
            "status": 1002,
            "message": "Resource busy!"
        }

# Group Time
Notes related resources of the **Time API**

## Time [/system/time]
The system time information include NTP client settings

### Retrieve system time information [GET]

The response for GET has following attributes:

- **time** (string, `2014-10-21 00:00:00`): Current system time. (iso 8601)
- **timezone** (string, `+08,00,0`): System timezone settings.
- **ntp.enable** (boolean, `enable`): Enable/Disable Ntp client.
- **ntp.server** (string, `pool.ntp.org`): Ntp server.
- **ntp.interval** (integer, `86400`): Ntp update interval in seconds. (at least: 60 seconds.)

+ Response 200 (application/json; charset=utf-8)

    + Body

            {
                "time": "2015-03-26T16:27:48.611441Z",
                "timezone": "+08:00,0",
                "ntp": {
                    "enable": 1,
                    "server": "pool.ntp.org",
                    "interval": 86400
                }
            }

### Update system time properties [PUT]

The response for PUT has following attributes:

+ Request  (application/json; charset=utf-8)

    + Body

            {
                "time": "2015-03-26T16:27:48.611441Z",
                "timezone": "+08:00,0",
                "ntp": {
                    "enable": 0,
                    "server": "pool.ntp.org",
                    "interval": 86400
                }
            }

+ Response 200 (application/json; charset=utf-8)

    + Body

            {
                "time": "2015-03-26T16:27:48.611441Z",
                "timezone": "+08:00,0",
                "ntp": {
                    "enable": 1,
                    "server": "pool.ntp.org",
                    "interval": 86400
                }
            }


# Group DNS
Notes related resources of the **DNS API**

## Current DNS [/network/dns]
### List DNS Settings [GET]

The response has following attributes:

- **source** (optional, string): show the current dns corresponging source (maybe network interface or fixed DNS)
- **dns** (required, object array): show current running dns servers.
- **enableFixed** (required, bool): using fixed DNS (`true`) or by interface (`false`)
- **fixedDNS** (required, object array): show fixed dns servers.

+ Response 200 (application/json; charset=utf-8)

        {
            "enableFixed": false,
            "fixedDNS": [],
            "source": "eth0",
            "dns": ["8.8.8.8", "8.8.4.4", "192.168.50.33"]
        }

### Update DNS Settings [PUT]

The request for PUT has following attributes:

- **source** (optional, string, "fixed"): show the current dns corresponging interface
- **dns** (optional, string array, `["8.8.8.8", "8.8.4.4"]`): show current running dns servers.
- **enableFixed** (required, bool, `false`): using fixed DNS (`true`) or by interface (`false`), `false` if not given
- **fixedDNS** (optional, object array, `[]`): fixed dns servers.

+ Request  (application/json; charset=utf-8)

        {
            "source": "eth0"
        }

+ Response 200 (application/json; charset=utf-8)

        {
            "enableFixed": false,
            "source": "eth0",
            "dns": ["8.8.8.8", "8.8.4.4", "192.168.50.33"],
            "fixedDNS": []
        }

+ Request  (application/json; charset=utf-8)

        {
            "dns": ["8.8.8.8", "8.8.4.4", "192.168.50.33"]
        }

+ Response 200 (application/json; charset=utf-8)

        {
            "enableFixed": false,
            "fixedDNS": [],
            "dns": ["8.8.8.8", "8.8.4.4", "192.168.50.33"]
        }

+ Request  (application/json; charset=utf-8)

        {
            "enableFixed": true,
            "fixedDNS": ["8.8.8.8", "8.8.4.4"]
        }

+ Response 200 (application/json; charset=utf-8)

        {
            "enableFixed": true,
            "source": "fixed",
            "dns": ["8.8.8.8", "8.8.4.4"],
            "fixedDNS": ["8.8.8.8", "8.8.4.4"]
        }

+ Request  (application/json; charset=utf-8)
## DNS Database [/network/dns/db]
### List DNS Settings by Interfaces [GET]

The response has following attributes:

- **source** (required, string): interface that dns servers belong to
- **dns** (required, object array): dns servers

+ Response 200 (application/json; charset=utf-8)

        [
            {
                "source": "fixed",
                "dns": ["8.8.8.8", "8.8.4.4"],
            },
            {
                "source": "eth0",
                "dns": ["192.168.50.36", "192.168.50.33"],
            },
            {
                "source": "eth1",
                "dns": ["8.8.8.8", "8.8.4.4"],
            },
            {
                "source": "wwlan0",
                "dns": ["168.95.1.1"]
            }
        ]

### Update DNS Database [PUT]

+ Request  (application/json; charset=utf-8)

        {
            "source": "eth0"
            "dns": ["8.8.8.8", "8.8.4.4"]
        }

+ Response 200 (application/json; charset=utf-8)

        {
            "source": "eth0"
            "dns": ["8.8.8.8", "8.8.4.4"]
        }

+ Request  (application/json; charset=utf-8)

        [
            {
                "source": "eth0"
                "dns": ["8.8.8.8", "8.8.4.4"]
            },
            {
                "source": "eth1",
                "dns": ["8.8.8.8", "8.8.4.4", "192.168.50.33"],
            },
            {
                "source": "wwlan0",
                "dns": ["8.8.8.8", "8.8.4.4", "192.168.50.33"],
            }
        ]

+ Response 200 (application/json; charset=utf-8)

        [
            {
                "source": "eth0"
                "dns": ["8.8.8.8", "8.8.4.4"]
            },
            {
                "source": "eth1",
                "dns": ["8.8.8.8", "8.8.4.4", "192.168.50.33"],
            },
            {
                "source": "wwlan0",
                "dns": ["8.8.8.8", "8.8.4.4", "192.168.50.33"],
            }
        ]

## DNS Servers of Given Interface [/network/dns/{source}]
### List DNS Servers of Given Interface [GET]

The response has following attributes:

- **dns** (required, object array): dns servers

+ Response 200 (application/json; charset=utf-8)

        ["8.8.8.8", "8.8.4.4"]

### Update DNS Database by Interface [PUT]

+ Request  (application/json; charset=utf-8)

        ["8.8.8.8", "8.8.4.4"]

+ Response 200 (application/json; charset=utf-8)

        ["8.8.8.8", "8.8.4.4"]


# Group Status
Notes related resources of the **Status API**

## System status [/system/status]
### Get System Status data [GET]

The response has following attributes:

- **hostname** (required, string): show hostname
- **version** (required, string): show product version
- **uptime** (required, integer): show uptime of machine
- **memory** (required, integer): system memory size (unit: byte)
- **disks[].name** (required, string): disk alias
- **disks[].mount** (required, string): mount point
- **disks[].device** (required, string): disk device
- **disks[].usage.total** (required, integer): show total storage size (unit: byte)
- **disks[].usage.used** (required, integer): show used storage size (unit: byte)
- **disks[].usage.free** (required, integer): show free storage size (unit: byte)
- **disks[].usage.percent** (required, integer): show used storage percent


+ Response 200 (application/json; charset=utf-8)

        {
            "hostname": "Moxa",
            "version": "1.1.0-1",
            "uptimeSec": 312956,
            "memory": 257286144,
            "disks": [
                {
                    "name": "system",
                    "mount": "/",
                    "device": "rootfs",
                    "usage": {
                        "total": 770695168,
                        "used": 497655808,
                        "free": 217038848,
                        "percent": 64.6
                    }
                },
                {
                    "name": "sd1",
                    "mount": "/media/sd-mmcblk1p1",
                    "device": "/dev/mmcblk1p1",
                    "usage": {
                        "total": 770695168,
                        "used": 497655808,
                        "free": 217038848,
                        "percent": 64.6
                    }
                }
            ]
        }

### Set system hostname [PUT]

+ Request  (application/json; charset=utf-8)

        {
            "hostname": "moxa"
        }

+ Response 200 (application/json; charset=utf-8)

        {
            "hostname": "moxa"
        }


# Group Watchdog
Notes related resources of the **Watchdog API**

## Watchdog [/system/watchdog]
### List Watchdog Register Process [GET]

The response has following attributes:

- **process** (required, object array): list of register watchdog.

+ Response 200 (application/json)

        [
            {
                "id" : 1,
                "process" : "process name",
                "path" : "/usr/bin/process_name"
            }
            {
                "id" : 2,
                "process" : "process name",
                "path" : "/usr/bin/process_name"

            }
        ]

### Add Process to watchdog [PUT]


+ Request  (application/json)

        {
            "process": "process_name",
            "path": "/usr/bin/process_name"
        }


+ Response 200 (application/json)

        {
            "id": 1,
            "message": "success"
        }

+ Response 400 (application/json)

        {
            "id": 1,
            "message": "Process already register"
        }

### Delete Monitor Process from watchdog [DELETE]
/system/watchdog/1

+ Request  (application/json)

        {
            "process": "process_name"
        }


+ Response 200 (application/json)

        {
            "status": 200
        }


# Group IP Route
Notes related resources of the **IPRoute API**

## Available Interfaces [/network/routes/interfaces]
### List Available Interfaces [GET]

+ Response 200 (application/json)

        ["eth0", "eth1"]

## Default Gateway [/network/routes/default]
### Retrieve Default Gateway [GET]

The response has following attributes:

- **interface** (optional, string, `eth0`): interface to be set as the default gateway.
- **gateway** (optional, IP address, `192.168.31.254`): gateway address.

+ Response 200 (application/json)

        {
            "interface": "eth0",
            "gateway": "192.168.31.254"
        }

### Update Default Gateway [PUT]

The request and response has following attributes:

- **interface** (optional, string, `eth0`): interface to be set as the default gateway.
- **gateway** (optional, IP address, `192.168.31.254`): gateway address.

+ Request  (application/json)

        {}

+ Response 200 (application/json)

        {}

+ Request  (application/json)

        {
            "interface": "",
        }

+ Response 200 (application/json)

        {
            "interface": "",
        }

+ Request  (application/json)

        {
            "interface": "wwan0",
        }

+ Response 200 (application/json)

        {
            "interface": "wwan0",
            "gateway": "192.168.3.254"
        }

+ Response 404 (application/json)

        {
            "status": "40451",
            "message": "Update default gateway failed."
        }

## Default Gateway [/network/routes/secondary]
### Retrieve Secondary Default Gateway [GET]

The response has following attributes:

- **interface** (optional, string, `eth0`): interface to be set as the default gateway.
- **gateway** (optional, IP address, `192.168.31.254`): gateway address.

+ Response 200 (application/json)

        {
            "interface": "eth0",
            "gateway": "192.168.31.254"
        }

### Update Secondary Default Gateway [PUT]

The request and response has following attributes:

- **interface** (optional, string, `eth0`): interface to be set as the default gateway.
- **gateway** (optional, IP address, `192.168.31.254`): gateway address.

+ Request  (application/json)

        {}

+ Response 200 (application/json)

        {}

+ Request  (application/json)

        {
            "interface": "",
        }

+ Response 200 (application/json)

        {
            "interface": "",
        }

+ Request  (application/json)

        {
            "interface": "eth0",
        }

+ Response 200 (application/json)

        {
            "interface": "eth0",
            "gateway": "192.168.3.254"
        }

## Router Database [/network/routes/db]

### List Router Database by Interface [GET]

The response has following attributes:

- **interface** (optional, string, `eth0`): interface name.
- **gateway** (optional, IP address, `192.168.31.254`): gateway address.

+ Response 200 (application/json; charset=utf-8)

        [
            {
                "interface": "eth0",
                "gateway": "192.168.3.254"
            },
            {
                "interface": "eth1",
                "gateway": "192.168.4.254"
            },
            {
                "interface": "wwlan0",
                "gateway": "192.168.5.254"
            }
        ]

### Update Router Database [PUT]

The request and response has following attributes:

- **interface** (optional, string, `eth0`): interface name.
- **gateway** (optional, IP address, `192.168.31.254`): gateway address.

+ Request  (application/json)

        {
            "interface": "eth1",
            "gateway": "192.168.4.254"
        }

+ Response 200 (application/json)

        {
            "interface": "eth1",
            "gateway": "192.168.4.254"
        }

+ Request  (application/json)

        [
            {
                "interface": "eth0",
                "gateway": "192.168.3.254"
            },
            {
                "interface": "eth1",
                "gateway": "192.168.4.254"
            },
            {
                "interface": "wwlan0",
                "gateway": "192.168.5.254"
            }
        ]

+ Response 200 (application/json; charset=utf-8)

        [
            {
                "interface": "eth0",
                "gateway": "192.168.3.254"
            },
            {
                "interface": "eth1",
                "gateway": "192.168.4.254"
            },
            {
                "interface": "wwlan0",
                "gateway": "192.168.5.254"
            }
        ]

# Group Network
Notes related resources of the **network**

## Network Interface List [/network/interfaces]
### Get Interface List [GET]

Reply a string array with interface name.

+ Response 200 (application/json; charset=utf-8)

        ["eth0", "eth1", "usb0"]

## Network Interface Information [/network/interface]
### Update the interface information [PUT]

The request for PUT has following attributes (this is an **event** message):

- **name** (required, string, `eth0`): Indicate the interface name.
- **ip** (required, IP address, `192.168.3.127`): IP address for the network interface.
- **netmask** (required, IP address, `255.255.255.0`): Subnet mask for the network interface.
- **subnet** (required, IP address, `192.168.3.0`): A subnet (short for "subnetwork") is an identifiably separate part of an organization's network.
- **gateway** (required, IP address, `192.168.3.254`): Gateway is a router or a proxy server that routes between networks.
- **dns** (required, IP address array): The Domain Name System (DNS) is a hierarchical distributed naming system for computers, services, or any resource connected to the Internet or a private network.

+ Request (application/json)

        {
            "name": "eth0",
            "ip":"192.168.3.127",
            "netmask":"255.255.255.0",
            "subnet":"192.168.3.0",
            "gateway":"192.168.3.254",
            "dns":["8.8.8.8", "8.8.4.4"],
        }

+ Response 200 (application/json)

        {
        }


# Group Serial Interface

## Serial Interface Collection [/system/serial]

A interface object has the following attributes:

- **id** (required, integer, `1`): Interface ID.
- **dev** (required, string, `ioLogik-E2210`): Device node path (readonly)
- **devDisplayName** (required, string, `ioLogik-E2210`): Display name (readonly)
- **mode** (required, string, `rs232`): Type of interface. Could be one of `rs232`, `rs485-2w`, `rs422/rs485-4w`

### Get all serial interfaces [GET]

+ Response 200 (application/json)

        [
            {
              "id": 1,
              "dev": "/dev/ttyM0",
              "devDisplayName": "PORT 1",
              "mode": "rs232"
            },
            {
              "id": 2,
              "dev": "/dev/ttyM1",
              "devDisplayName": "PORT 2",
              "mode": "rs485-2w"
            },
            {
              "id": 3,
              "dev": "/dev/ttyM2",
              "devDisplayName": "PORT 3",
              "mode": "rs422/rs485-4w"
            }
        ]

## Serial Interface [/system/serial/{id}]

+ Parameter
    + id: 1 (required, number) - ID of the Serial Interface in form of an integer

### Update a serial interface [PUT]

+ Request (application/json)

        {
            "mode": "rs485-2w"
        }

+ Response 200 (application/json)

        {
          "id": 1,
          "dev": "/dev/ttyM0",
          "devDisplayName": "PORT 1",
          "mode": "rs485-2w"
        }

# Group Serial Interface

## Serial Interface Collection [/system/serial]

A interface object has the following attributes:

- **id** (required, integer, `1`): Interface ID.
- **dev** (required, string, `ioLogik-E2210`): Device node path (readonly)
- **devDisplayName** (required, string, `ioLogik-E2210`): Display name (readonly)
- **mode** (required, string, `rs232`): Type of interface. Could be one of `rs232`, `rs485-2w`, `rs422/rs485-4w`

### Get all serial interfaces [GET]

+ Response 200 (application/json)

        [
            {
              "id": 1,
              "dev": "/dev/ttyM0",
              "devDisplayName": "PORT 1",
              "mode": "rs232"
            },
            {
              "id": 2,
              "dev": "/dev/ttyM1",
              "devDisplayName": "PORT 2",
              "mode": "rs485-2w"
            },
            {
              "id": 3,
              "dev": "/dev/ttyM2",
              "devDisplayName": "PORT 3",
              "mode": "rs422/rs485-4w"
            }
        ]

## Serial Interface [/system/serial/{id}]

+ Parameter
    + id: 1 (required, number) - ID of the Serial Interface in form of an integer

### Update a serial interface [PUT]

+ Request (application/json)

        {
            "mode": "rs485-2w"
        }

+ Response 200 (application/json)

        {
          "id": 1,
          "dev": "/dev/ttyM0"
          "devDisplayName": "PORT 1",
          "mode": "rs485-2w"
        }

# Group System Log

## System Log [/system/syslog]

### Download system logs [GET]

The response for GET would be a file.
(From web to backend)

+ Request  (application/json)

+ Response 200 (application/octet-stream)

        ```binary data goes here```

### Download system logs [POST]
(From backend to bundle)
The response for GET has following attributes:

+ Request  (application/json)

        {
          "url": "https://server/upload",
          "headers": {
            "accessToken": "MOXAMOXA-TEST-SYSTEM"
          }
        }

+ Response 200 (application/json)

        {
          "url": "https://server/upload/xxxxxxx"
        }



# Group Port Mapping
Notes related resources of the **Port Mapping API**

## PortMapping Collection [/network/portmapping]
### List all Port Mappings [GET]

The Collection response has following attributes:

+ Response 200 (application/json)

        [
          {
            "id": 1,
            "enable": true,
            "service": "http",
            "portStart": 80,
            "portEnd": 80,
            "destIP": "192.168.5.123",
            "protocol": "both"
          }
        ]

### Create a PortMapping Rule [POST]

The response for POST has following attributes:

+ Request  (application/json)

        {
            "enable": true,
            "service": "modbus-1",
            "portStart": 502,
            "portEnd": 502,
            "destIP": "192.168.5.124",
            "protocol": "tcp"
        }

+ Response 200 (application/json)

        {
            "id": 2,
            "enable": true,
            "service": "modbus-1",
            "portStart": 502,
            "portEnd": 502,
            "destIP": "192.168.5.124",
            "protocol": "tcp"
        }


## PortMapping [/network/portmapping/{id}]
A single PortMapping object with all its details

+ Parameters
    + id (required, number, `1`) ... Numeric `id` of the PortMapping to perform action with. Has example value.

### Retrieve a PortMapping rule [GET]

The response for GET has following attributes:

- **id** (number, `1`): Identifier for a Port Mapping item.
- **enable** (boolean, `true`): Indicate to enable (`true`) or disable (`false`) the rule.
- **service** (string, `http`): Indicate the service for Port Mapping.
- **portStart** (number, `80`): Start port.
- **portEnd** (number, `80`): End port.
- **destIp** (IP address, `111.70.146.125`): Destination IP address for the Port Mapping.
- **protocol** (string, `tcp`): could be one of `tcp`, `udp`, or `both`.

+ Response 200 (application/json; charset=utf-8)

        {
            "id": 1,
            "enable": true,
            "service": "http",
            "portStart": 80,
            "portEnd": 80,
            "destIP": "192.168.5.123",
            "protocol": "both"
        }


### Update a PortMapping [PUT]

The request for PUT has following attributes:

- **id** (required, number, `1`): Identifier for a Port Mapping item.
- **enable** (required, boolean, `true`): Indicate to enable (`true`) or disable (`false`) the rule.
- **service** (optional, string, `http`): Indicate the service for Port Mapping.
- **portStart** (required, number, `80`): Start port.
- **portEnd** (optional, number, `80`): End port, same as start port if not defined.
- **destIp** (required, IP address, `111.70.146.125`): Destination IP address for the Port Mapping.
- **protocol** (required, string, `tcp`): could be one of `tcp`, `udp`, or `both`.


The error response has following attributes:

- **status** (required, number, `1100`): Status code for error message.
- **message** (required, string): Error message in English.

+ Request (application/json)

        {
            "id": 1,
            "enable": true,
            "service": "http",
            "portStart": 80,
            "portEnd": 80,
            "destIP": "192.168.5.123",
            "protocol": "both"
        }

+ Response 200 (application/json)

        {
            "id": 1,
            "enable": true,
            "service": "http",
            "portStart": 80,
            "portEnd": 80,
            "destIP": "192.168.5.123",
            "protocol": "both"
        }

+ Response 400 (application/json)

        {
              "message": "Unable to apply!"
        }

### Delete a PortMapping Rule [DELETE]

+ Response 200 (application/json)



# Group Simple Source NAT
Notes related resources of the **Simple Source NAT API**

## Simple Source NAT Collection [/network/ssnat]
### List all SSNAT entries [GET]

The Collection response has following attributes:

+ Response 200 (application/json)

        [
          {
            "id": 1,
            "enable": true,
            "service": "http",
            "protocol": "both",
            "intIP": "192.168.5.123",
            "portStart": 80,
            "portEnd": 80,
            "outInterface": "wan"
          }
        ]

### Create an SSNAT Rule [POST]
#
The response for POST has following attributes:

+ Request  (application/json)

        {
            "enable": true,
            "service": "modbus-1",
            "portStart": 502,
            "portEnd": 502,
            "intIP": "192.168.5.124",
            "protocol": "tcp",
            "outInterface": "wan"
        }

+ Response 200 (application/json)

        {
            "id": 2,
            "enable": true,
            "service": "modbus-1",
            "portStart": 502,
            "portEnd": 502,
            "intIP": "192.168.5.124",
            "protocol": "tcp",
            "outInterface": "wan"
        }


## SSNAT [/network/ssnat/{id}]
A single SSNAT object with all its details

+ Parameters
    + id (required, number, `1`) ... Numeric `id` of the PortMapping to perform action with. Has example value.

### Retrieve an SSNAT rule [GET]

The response for GET has following attributes:

- **id** (number, `1`): Identifier for an SSNAT item.
- **enable** (boolean, `true`): Indicate to enable (`true`) or disable (`false`) the rule.
- **service** (string, `http`): Indicate the service for Port Mapping.
- **portStart** (number, `80`): Start port.
- **portEnd** (number, `80`): End port.
- **intIp** (IP address, `111.70.146.125`): Internal (source) IP address for the source NAT.
- **protocol** (string, `tcp`): could be one of `tcp`, `udp`, or `both`.
- **outInterface** (string, `wan`): could the interface name or "wan" to indicate a WAN interface.

+ Response 200 (application/json; charset=utf-8)

        {
            "id": 1,
            "enable": true,
            "service": "http",
            "portStart": 80,
            "portEnd": 80,
            "intIP": "192.168.5.123",
            "protocol": "both",
            "outInterface": "wan"
        }


### Update an SSNAT [PUT]

The request for PUT has following attributes:

- **id** (required, number, `1`): Identifier for an SSNAT item.
- **enable** (required, boolean, `true`): Indicate to enable (`true`) or disable (`false`) the rule.
- **service** (optional, string, `http`): Indicate the service for Port Mapping.
- **portStart** (required, number, `80`): Start port.
- **portEnd** (optional, number, `80`): End port, same as start port if not defined.
- **intIp** (required, IP address, `111.70.146.125`): Internal (source) IP address for the source NAT.
- **protocol** (required, string, `tcp`): could be one of `tcp`, `udp`, or `both`.
- **outInterface** (required, string, `wan`): could the interface name or "wan" to indicate a WAN interface.


The error response has following attributes:

- **status** (required, number, `1100`): Status code for error message.
- **message** (required, string): Error message in English.

+ Request (application/json)

        {
            "id": 1,
            "enable": true,
            "service": "http",
            "portStart": 80,
            "portEnd": 80,
            "intIP": "192.168.5.123",
            "protocol": "both",
            "outInterface": "wan"
        }

+ Response 200 (application/json)

        {
            "id": 1,
            "enable": true,
            "service": "http",
            "portStart": 80,
            "portEnd": 80,
            "intIP": "192.168.5.123",
            "protocol": "both",
            "outInterface": "wan"
        }

+ Response 400 (application/json)

        {
              "message": "Unable to apply!"
        }

### Delete an SSNAT Rule [DELETE]

+ Response 200 (application/json)


# Group Service
Notes related resources of the **Service API**

## Service Collection [/system/services]
### List all Services [GET]

The Collection response has following attributes:

+ Response 200 (application/json)

        [
          {
            "id": 1,
            "enable": true,
            "name": "ssh",
            "status": true
          },
          {
            "id": 2,
            "enable": true,
            "name": "rsyslog",
            "status": true
          }
        ]

## Service [/system/services/{name}]
A single Service object with all its details

+ Parameters
    + name (required, number, `ssh`) ... The unique service name.


### Retrieve an Service [GET]

The response for GET has following attributes:

- **id** (number, `1`): Identifier for an Service item.
- **enable** (boolean, `true`): Indicate to enable (`true`) or disable (`false`) the service.
- **name** (string, `http`): Indicate the service name.
- **status** (boolean, `true`): Indicate the current status of service.

+ Response 200 (application/json; charset=utf-8)

        {
            "id": 1,
            "enable": true,
            "name": "ssh",
            "status": true
        }


### Update an Service [PUT]

The request for PUT has following attributes:

- **enable** (required, boolean, `true`): Indicate to enable (`true`) or disable (`false`) the service.


The error response has following attributes:

- **status** (required, number, `1100`): Status code for error message.
- **message** (required, string): Error message in English.

+ Request (application/json)

        {
            "enable": true
        }

+ Response 200 (application/json)

        {
            "id": 1,
            "enable": true,
            "name": "ssh",
            "status": true
        }

+ Response 400 (application/json)

        {
              "message": "No such service."
        }


## System Mode [/system/mode]

- **enableMode** (required, string): Avaliable modes: `cellular-router`, `modbus-application`

### Set system mode [PUT]

+ Request (application/json)

        {
          "enableMode": "cellular-router"
        }

The response for PUT has following attributes:

+ Response 200 (application/json)

        {
          "enableMode": "cellular-router"
        }

### Get system mode [GET]

The response for GET has following attributes:

+ Response 200 (application/json)

        {
          "enableMode": "modbus-application"
        }


# Group Firewall for WAN
Notes related resources of the **Firewall API**

## HTTPS [/network/firewall/wan/https]
Firewall for HTTPS status on WAN

### Retrieve the Setting [GET]

The response for GET has following attributes:

- **enable** (boolean, `true`): Indicate to enable (`true`) or disable (`false`) the https access via WAN.

+ Response 200 (application/json; charset=utf-8)

        {
            "enable": true
        }


### Update the Setting [PUT]

The request for PUT has following attributes:

- **enable** (required, boolean, `true`): Indicate to enable (`true`) or disable (`false`) the https access via WAN.


The error response has following attributes:

- **status** (required, number, `1100`): Status code for error message.
- **message** (required, string): Error message in English.

+ Request (application/json)

        {
            "enable": false
        }

+ Response 200 (application/json)

        {
            "enable": false
        }

